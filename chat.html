<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Secure P2P Chat â€“ All-in-One</title>
<style>
body { background:#0b0f14; color:#eaeaea; font-family: monospace; padding:20px; }
textarea,input,button { width:100%; margin-top:8px; background:#111; color:#0f0; border:1px solid #333; padding:8px; }
#chat { border:1px solid #222; height:250px; overflow:auto; padding:6px; margin-top:10px; }
button { cursor:pointer; }
hr { border:1px solid #222; margin:15px 0; }
</style>
</head>
<body>

<h2>ðŸ”’ Secure P2P Chat â€“ All-in-One</h2>

<!-- Identity -->
<p><b>Your Public Key:</b></p>
<textarea id="pub" rows="4" placeholder="Your public key"></textarea>
<button onclick="generateIdentity()">Generate Identity</button>
<button onclick="loadIdentity()">Load Saved Identity</button>

<hr>

<!-- Peer key & shared key -->
<textarea id="peerKey" rows="4" placeholder="Paste PEER public key here"></textarea>
<button onclick="deriveSharedKey()">Derive Shared Key</button>

<hr>

<!-- Signaling -->
<textarea id="signal" rows="4" placeholder="Signaling data"></textarea>
<button onclick="createOffer()">Create Offer</button>
<button onclick="acceptSignal()">Accept Signal</button>

<hr>

<!-- Chat -->
<div id="chat"></div>
<input id="msg" placeholder="Message">
<button onclick="send()">Send</button>

<script>
let pc = new RTCPeerConnection();
let channel = null;
let sharedKey = null;

// --- Identity ---
async function generateIdentity(){
  try{
    const keyPair = await crypto.subtle.generateKey({name:"ECDH", namedCurve:"P-256"}, true, ["deriveKey"]);
    const rawPub = await crypto.subtle.exportKey("raw", keyPair.publicKey);
    const pubB64 = btoa(String.fromCharCode(...new Uint8Array(rawPub)));
    document.getElementById("pub").value = pubB64;

    const privJwk = await crypto.subtle.exportKey("jwk", keyPair.privateKey);
    localStorage.setItem("privateKey", JSON.stringify(privJwk));
    window._privateKey = keyPair.privateKey;
    alert("Identity generated & saved!");
  }catch(e){ console.error(e); alert("Failed to generate identity"); }
}

async function loadIdentity(){
  const saved = localStorage.getItem("privateKey");
  if(!saved){ alert("No saved key"); return; }
  try{
    const jwk = JSON.parse(saved);
    window._privateKey = await crypto.subtle.importKey("jwk", jwk, {name:"ECDH",namedCurve:"P-256"}, true, ["deriveKey"]);
    alert("Private key loaded!");
  }catch(e){ console.error(e); alert("Failed to load key"); }
}

// --- Shared AES key ---
async function deriveSharedKey(){
  if(!window._privateKey) { await loadIdentity(); if(!window._privateKey) return; }
  try{
    const raw = Uint8Array.from(atob(document.getElementById("peerKey").value.trim()), c=>c.charCodeAt(0));
    const peerPublicKey = await crypto.subtle.importKey("raw", raw, {name:"ECDH", namedCurve:"P-256"}, false, []);
    sharedKey = await crypto.subtle.deriveKey({name:"ECDH", public:peerPublicKey}, window._privateKey, {name:"AES-GCM", length:256}, false, ["encrypt","decrypt"]);
    alert("ðŸ”‘ Shared key established!");
  }catch(e){ console.error(e); alert("Key derivation failed"); }
}

// --- WebRTC ---
pc.ondatachannel = e=>{ channel=e.channel; setupChannel(); };
function setupChannel(){
  channel.onmessage = async e=>{ const text=await decrypt(e.data); addMsg("Peer", text); };
}

// --- Signaling ---
async function createOffer(){
  channel = pc.createDataChannel("secure"); setupChannel();
  const offer = await pc.createOffer();
  await pc.setLocalDescription(offer);
  document.getElementById("signal").value = JSON.stringify(pc.localDescription);
}
async function acceptSignal(){
  const data = JSON.parse(document.getElementById("signal").value);
  if(data.type==="offer"){
    await pc.setRemoteDescription(data);
    const answer = await pc.createAnswer();
    await pc.setLocalDescription(answer);
    document.getElementById("signal").value = JSON.stringify(pc.localDescription);
  }else{
    await pc.setRemoteDescription(data);
  }
}

// --- Encrypt / Decrypt ---
async function encrypt(text){
  const iv=crypto.getRandomValues(new Uint8Array(12));
  const enc=new TextEncoder().encode(text);
  const cipher = await crypto.subtle.encrypt({name:"AES-GCM",iv}, sharedKey, enc);
  return JSON.stringify({iv:Array.from(iv),data:Array.from(new Uint8Array(cipher))});
}
async function decrypt(payload){
  const obj=JSON.parse(payload);
  const iv=new Uint8Array(obj.iv);
  const data=new Uint8Array(obj.data);
  const plain = await crypto.subtle.decrypt({name:"AES-GCM",iv}, sharedKey, data);
  return new TextDecoder().decode(plain);
}

// --- Send message ---
async function send(){
  if(!sharedKey || !channel || channel.readyState!=="open"){ alert("Shared key or connection not ready"); return; }
  const text=document.getElementById("msg").value;
  const enc = await encrypt(text);
  channel.send(enc);
  addMsg("Me", text);
  document.getElementById("msg").value="";
}

// --- UI helper ---
function addMsg(who,text){ document.getElementById("chat").innerHTML+=`<div><b>${who}:</b> ${text}</div>`; }

</script>
</body>
</html>