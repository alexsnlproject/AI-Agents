<script>
let pc = new RTCPeerConnection();
let channel;
let sharedKey = null;

// DataChannel setup
pc.ondatachannel = e => {
  channel = e.channel;
  setupChannel();
};

function setupChannel() {
  channel.onopen = () => {
    console.log("Data channel open");
  };
  channel.onmessage = async e => {
    if (!sharedKey) {
      add("System","Shared key not derived yet!");
      return;
    }
    const text = await decrypt(e.data);
    add("Peer", text);
  };
}

// --- Signaling ---
async function createOffer() {
  if (!window._privateKey) {
    alert("Generate your identity first!");
    return;
  }

  // Î´Î·Î¼Î¹Î¿Ï…ÏÎ³Î¿ÏÎ¼Îµ data channel
  channel = pc.createDataChannel("secure");
  setupChannel();

  // Î´Î·Î¼Î¹Î¿Ï…ÏÎ³Î¯Î± offer
  const offer = await pc.createOffer();
  await pc.setLocalDescription(offer);

  // Î ÎµÏÎ¹Î¼Î­Î½Î¿Ï…Î¼Îµ Î½Î± Î´Î·Î¼Î¹Î¿Ï…ÏÎ³Î·Î¸ÎµÎ¯ Ï„Î¿ SDP Ï€ÏÎ¹Î½ Ï„Î¿ ÎµÎ¼Ï†Î±Î½Î¯ÏƒÎ¿Ï…Î¼Îµ
  pc.onicecandidate = e => {
    if (!e.candidate) {
      // ICE gathering complete
      signal.value = JSON.stringify(pc.localDescription);
    }
  };
}

async function acceptSignal() {
  if (!window._privateKey) {
    alert("Generate your identity first!");
    return;
  }

  const data = JSON.parse(signal.value);

  pc.onicecandidate = e => {
    if (!e.candidate) {
      signal.value = JSON.stringify(pc.localDescription);
    }
  };

  if (data.type === "offer") {
    await pc.setRemoteDescription(data);
    const answer = await pc.createAnswer();
    await pc.setLocalDescription(answer);
  } else {
    await pc.setRemoteDescription(data);
  }
}

// --- Chat ---
async function send() {
  if (!sharedKey || !channel || channel.readyState !== "open") {
    alert("Connection or key not ready");
    return;
  }

  const text = msg.value;
  const enc = await encrypt(text);
  channel.send(enc);
  add("Me", text);
  msg.value = "";
}

// --- Crypto ---
async function deriveSharedKey() {
  if (!window._privateKey) { alert("Generate identity first"); return; }
  try {
    const raw = Uint8Array.from(atob(peerKey.value.trim()), c=>c.charCodeAt(0));
    const peerPublicKey = await crypto.subtle.importKey(
      "raw",
      raw,
      { name: "ECDH", namedCurve: "P-256" },
      false,
      []
    );

    sharedKey = await crypto.subtle.deriveKey(
      { name: "ECDH", public: peerPublicKey },
      window._privateKey,
      { name:"AES-GCM", length:256 },
      false,
      ["encrypt","decrypt"]
    );
    alert("ðŸ”‘ Shared key established");
  } catch(e){console.error(e); alert("Key derivation failed");}
}

async function encrypt(text) {
  const iv = crypto.getRandomValues(new Uint8Array(12));
  const enc = new TextEncoder().encode(text);
  const cipher = await crypto.subtle.encrypt({name:"AES-GCM",iv},sharedKey,enc);
  return JSON.stringify({iv:Array.from(iv),data:Array.from(new Uint8Array(cipher))});
}

async function decrypt(payload) {
  const obj = JSON.parse(payload);
  const iv = new Uint8Array(obj.iv);
  const data = new Uint8Array(obj.data);
  const plain = await crypto.subtle.decrypt({name:"AES-GCM",iv},sharedKey,data);
  return new TextDecoder().decode(plain);
}

function add(who,text){ chat.innerHTML += `<div><b>${who}:</b> ${text}</div>`; }
</script>